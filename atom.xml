<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allunw&#39;s Blog</title>
  
  <subtitle>积跬步，聚小流</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://allunw.github.io/"/>
  <updated>2017-12-15T04:15:06.774Z</updated>
  <id>https://allunw.github.io/</id>
  
  <author>
    <name>Allunw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是同构JavaScript 应用？</title>
    <link href="https://allunw.github.io/2015/11/07/isomorphism-javascript-application/"/>
    <id>https://allunw.github.io/2015/11/07/isomorphism-javascript-application/</id>
    <published>2015-11-07T14:35:55.000Z</published>
    <updated>2017-12-15T04:15:06.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是同构？"><a href="#什么是同构？" class="headerlink" title="什么是同构？"></a>什么是同构？</h3><p>“Write once, run everywhere”这是一句形容Java的语句。现在Nodejs出来后Javascript也可以用这句话来描述了。这就引出了同构JavaScript应用的概念：一份代码同时在客户端和服务端渲染的JavaScript应用。</p><h3 id="单页应用的问题"><a href="#单页应用的问题" class="headerlink" title="单页应用的问题"></a>单页应用的问题</h3><p>同构JavaScript应用一直以来就是人们追寻的目标，单页应用是其中之一。单页拥有良好的交互体验，却带来一些其他问题： SEO和性能。</p><ol><li>SEO可以说是单页应用的硬伤，这导致很多需要搜索引擎的页面不能体验到单页的良好交互体验。</li><li>同时首屏性能也是单页的一个瓶颈，有些需要高性能首屏展示的网站也只能与单页应用插件而过。</li></ol><p>根本原因我们可以看到是JavaScript只在客户端运行，而服务端生成出来客户能看到的内容。</p><h3 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h3><p>之前为了解决单页这样的问题我们通常有三种做法：</p><ol><li>利用服务端语言重写一套供搜索引擎索引的页面;</li><li>利用服务端语言将首屏渲染出来给到客户端;</li><li>写一个JavaScript解析器来解析客户端的脚本语言（例如服务端嵌入v8）;</li></ol><p>从这里看，前两种属于代码重复率高的方案，而第三种却牺牲了部分性能来达到目的。是否有其他方案呢？当然有，这就是本文的概念：同构。</p><h3 id="同构JavaScript应用来解决单页问题"><a href="#同构JavaScript应用来解决单页问题" class="headerlink" title="同构JavaScript应用来解决单页问题"></a>同构JavaScript应用来解决单页问题</h3><p>同构 JavaScript 应用基于 JavaScript 编写，可以在客户端和服务端运行。正因为此，你只需要写一次代码，就可以在服务端渲染静态页面，还可以在客户端完成复杂的交互。这样就解决了上面两个问题。</p><p>这里我觉得，Nodejs才是同构的关键。我们来看看现在的一些应用:</p><p>当前流行的模板引擎React.js, Handlebars, jade，这些我们完全可以nodejs和前端单页用同一套。</p><p>JavaScript框架Rendr,Meteor, underscore等。</p><p>同构的目标：一码多地运行，更少的代码，更优的方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是同构？&quot;&gt;&lt;a href=&quot;#什么是同构？&quot; class=&quot;headerlink&quot; title=&quot;什么是同构？&quot;&gt;&lt;/a&gt;什么是同构？&lt;/h3&gt;&lt;p&gt;“Write once, run everywhere”这是一句形容Java的语句。现在Nodejs出来后J
      
    
    </summary>
    
      <category term="前端技术" scheme="https://allunw.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Javascript" scheme="https://allunw.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局之基础语法</title>
    <link href="https://allunw.github.io/2015/10/30/flex-grammer/"/>
    <id>https://allunw.github.io/2015/10/30/flex-grammer/</id>
    <published>2015-10-30T06:46:05.000Z</published>
    <updated>2017-12-14T06:45:20.072Z</updated>
    
    <content type="html"><![CDATA[<p>布局的传统解决方案，基于<strong>盒装模型</strong>,依赖 <em>display</em> 属性 + <em>position</em> 属性 + <em>float</em> 属性。它对于那些特殊布局非常不方便，比如垂直居中就不容易实现。<br>2009年，W3C提出了一种新式布局–Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就很安全地使用这项功能。</p><h3 id="一、Flex布局"><a href="#一、Flex布局" class="headerlink" title="一、Flex布局"></a>一、Flex布局</h3><p>Flex是Flexible Box的缩写，意为‘弹性布局’，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex布局。</p><pre><code>.box {    display: flex;}</code></pre><p>行内元素也可以使用Flex布局</p><pre><code>.box {    display: inline-block;}</code></pre><p>Webkit内核的浏览器，必须加上-webkit前缀。</p><pre><code>.box {    display: -webkit-flex;    display: flex;}</code></pre><p>注意设为Flex布局以后，子元素的float、clear和vertical-align属性将会失效</p><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>采用Flex布局的元素，成为Flex Container。它的所有子元素自动成为容器成员，称为flex item。</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start,结束位置叫做man end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。</p><pre><code>- flex-direction- flex-wrap- flex-flow- justify-content- align-items- align-content</code></pre><h5 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><pre><code>.box {    flex-direction: row | row-reverse | column | column-reverse}</code></pre><h5 id="3-2-flex-wrap"><a href="#3-2-flex-wrap" class="headerlink" title="3.2 flex-wrap"></a>3.2 flex-wrap</h5><p>默认情况下，项目都排在一条轴线上。flex-wrap属性定义，如果一条轴线排不下时，如何换行。</p><pre><code>.box {    flex-wrap: nowrap | wrap | wrap-reverse}wrap-reverse: 换行，第一行在下面</code></pre><h5 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h5><p>flex-flow属性是flex-direction和flex-wrap的简写形式，默认为 row wrap；</p><h5 id="3-4-justify-content"><a href="#3-4-justify-content" class="headerlink" title="3.4 justify-content"></a>3.4 justify-content</h5><p>justify-content属性定义了项目在主轴上的对齐方式。</p><pre><code>.box {    justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre><h5 id="3-5-align-items"><a href="#3-5-align-items" class="headerlink" title="3.5 align-items"></a>3.5 align-items</h5><p>align-items定义项目在交叉轴上如何对齐。</p><pre><code>.box {    align-items: flex-start | flex-end | center | baseline | stretch}center: 交叉轴中点对齐。baseline: 项目中第一行文字的基线对齐。stretch: 项目将以项目中最大的高度值为标准拉伸至一致。如果项目未设置高度或设为auto,将占满整个容器的高度。</code></pre><h5 id="3-6-align-content"><a href="#3-6-align-content" class="headerlink" title="3.6 align-content"></a>3.6 align-content</h5><p>align-content属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。</p><pre><code>.box {    align-content: flex-start | flex-end | center | space-between | space-around | stretch;}  </code></pre><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上</p><pre><code>- order- flex-grow- flex-shrink- flex-basis- flex- align-self</code></pre><h5 id="4-1-order"><a href="#4-1-order" class="headerlink" title="4.1 order"></a>4.1 order</h5><p>order定义项目的排列顺序。数值越少，排列越靠前，默认为0。</p><h5 id="4-3-flex-grow"><a href="#4-3-flex-grow" class="headerlink" title="4.3 flex-grow"></a>4.3 flex-grow</h5><p>flex-grow属性定义项目的放大比例，默认为0，如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h5 id="4-4-flex-shrink"><a href="#4-4-flex-shrink" class="headerlink" title="4.4 flex-shrink"></a>4.4 flex-shrink</h5><p>flex-shrink属性定义项目的缩小比例，默认为1，如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><h5 id="4-5-flex-basis"><a href="#4-5-flex-basis" class="headerlink" title="4.5 flex-basis"></a>4.5 flex-basis</h5><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><h5 id="4-6-flex"><a href="#4-6-flex" class="headerlink" title="4.6 flex"></a>4.6 flex</h5><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><pre><code>.item {    flex : none | [ &lt;&apos;flex-grow&apos;&gt;, &lt;&apos;flex-shrink&apos;&gt; ? || &lt;&apos;flex-basis&apos;&gt; ]}</code></pre><p>该属性有两个快捷键：auot （1 1 auto）和none（0 0 auto）<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="4-7-align-self"><a href="#4-7-align-self" class="headerlink" title="4.7 align-self"></a>4.7 align-self</h5><p>align-self属性允许单个项目与其他项目有不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>.item {    align-self: flex-start | flex-end | center | baseline | stretch}</code></pre><p>该属性有6个值，除了auto,其他都与align-items属性完全一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;布局的传统解决方案，基于&lt;strong&gt;盒装模型&lt;/strong&gt;,依赖 &lt;em&gt;display&lt;/em&gt; 属性 + &lt;em&gt;position&lt;/em&gt; 属性 + &lt;em&gt;float&lt;/em&gt; 属性。它对于那些特殊布局非常不方便，比如垂直居中就不容易实现。&lt;br&gt;2009年
      
    
    </summary>
    
      <category term="前端技术" scheme="https://allunw.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS" scheme="https://allunw.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://allunw.github.io/2015/09/16/hello-world/"/>
    <id>https://allunw.github.io/2015/09/16/hello-world/</id>
    <published>2015-09-16T06:55:32.000Z</published>
    <updated>2017-12-14T06:45:09.001Z</updated>
    
    <content type="html"><![CDATA[<p>This is my first article in this blog. Finally, it’s work :).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is my first article in this blog. Finally, it’s work :).&lt;/p&gt;

      
    
    </summary>
    
      <category term="其它" scheme="https://allunw.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="https://allunw.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
</feed>
